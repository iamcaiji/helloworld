# 系统说明书
## 引言
* 系统开发背景：

该系统是基于NVM（non-volatile memory）这种新的硬件的产生并流行使用的前提下，传统的数据库的某些方面可能不适应于新的硬件的支持，所以要在新型硬件广泛使用之前设计一种更加能体现新型硬件优点的数据库系统，这就是实现该数据库的最初的动机。

* 系统实现的时间计划
   1. 5/4我们会发布v1版本，主要是实现了PAllocator以及LevelDB的使用
   2. 5/11之前我们会发布v2版本，FPTreeDB的插入和重载操作
   3. 5/18之前我们会发布v3版本，FPTreeDB的查询和更新操作
   4. 5/31之前我们会发布final版本，FPTreeDB的删除和所有剩余操作

## 系统介绍

* 功能简介：

 这个系统结合了非易失性内存和现今的磁盘存储的技术，将有必要的数据进行永久的保存，保证了掉电的时候可以快速进行重构，而且数据不会丢失等问题。当然还有当今的数据库系统应有的功能，只是对这些数据库系统的一个改进的方案。

* 基本原理：

基本原理和B+树大致是一样的，但是为了实现持久化，LeftNode会有一点不一样，InnerNode还是差别不大的，保存的是键而没有值。所以在这棵树的基础上对其进行增删查改以及重构的操作。至于我们没有NVM硬件的支持，所以我们用Intel的模拟NVM来做，使用PMDK的libpmem库编写程序来模拟操作NVM。


## 使用指导
对于用户而言，对于系统内部的实现不需要知道得太多，使用这个系统对数据进行管理只需要五个基本的操作就可以了，分别是增（insert）、删（delete）、改（update）、查（find）、重构（bulkLoading）。

* insert ---增加一条数据记录
* delete ---删除一条数据记录
* update ---更改一条数据记录的某些值
* find ---根据key查询一条或多条数据记录
* bulkLoading ---新建一棵树的时候会先看文件夹里是否有数据文件，有则进行重构，没有会新建一棵树

#### 阶段任务
由于现阶段还没实现树的重构以及其他操作，这个部分会持续更新。

---
（5.11更新）

#### 树的重构
* 直接对应函数：

bool FTPree::bulkLoading()

该函数的作用是，如果存在数据文件，那么就从保存的叶子节点里面获得keynode然后对根节点一直进行insertLeaf操作。

	
    bool FPTree::bulkLoading() {
    PAllocator *pAllocator = PAllocator::getAllocator();
    PPointer startPointer = pAllocator->getStartPointer();

    if (startPointer.fileId != ILLEGAL_FILE_ID){
        while(startPointer.fileId != ILLEGAL_FILE_ID){
            LeafNode *leafNode = new LeafNode(startPointer, this);

            KeyNode leaf;
            leaf.key = leafNode->getKey(0);
            leaf.node = leafNode;

            root->insertLeaf(leaf);

            startPointer = *leafNode->pNext;
        }
        return true;
    }
    return false;
    }

* 调用函数：

KeyNode* InnerNode::insertLeaf(const KeyNode& leaf)

插入叶子的函数，这里已经确保了这个中间节点的指针指向的就是叶子节点了，所以可以直接进行插入，如果叶子满了就分类，返回一个keynode，如果不满就返回NULL。

	KeyNode* InnerNode::insertLeaf(const KeyNode& leaf) {
	    if (nChild>0) keys[nKeys++] = leaf.key;
	    childrens[nChild++] = leaf.node;
	    if (nKeys>2*degree)return split();
	    return NULL;
	}

#### 插入操作
* 直接对应函数

KeyNode* InnerNode::insert(const Key& k, const Value& v);

递归插入，根据树现有的中间结点每一层找到要插入的位置，然后插入到最顶层的中间结点，所以如果产生分裂的话就会从下面往上面分裂，返回一个keynode，这个keynode的node指针是指向右边结点的。并且插入这个结点之后要保持中间结点的有序性。

	KeyNode* InnerNode::insert(const Key& k, const Value& v) {
	    int index = findIndex(k);
	    
	    if (index == nChild)childrens[nChild++] = new LeafNode(tree);
	
	    KeyNode *newChild = childrens[index]->insert(k,v);
	    // 如果需要插入节点，顺序重排
	    if (newChild != NULL){
	        for (int i=nKeys++; i>index; i--)keys[i]=keys[i-1];
	        for (int i=nChild++; i>index+1; i--)childrens[i]=childrens[i-1];
	        keys[index]=newChild->key;
	        childrens[index+1]=newChild->node;
	    }
	    if (nKeys>2*degree)return split();
	    return NULL;
	}

*  调用函数

KeyNode* InnerNode::split();

中间结点分裂函数，中间结点最多有(2*d+1)个，所以分裂的时候前面d个保留在现在结点，中间的一个作为返回值keynode的key，后面d个key作为新的中间结点的值然后keynode的node指针指向这个新的中间结点。

int InnerNode::findIndex(const Key& k)；

通过二分查找找到比这个key大的第一个元素，其实就是找到应该要插入的位置。

void InnerNode::insertNonFull(const Key& k, Node* const& node);

这个函数假设插入一个keynode这个中间结点还没有满，所以不用考虑结点的分裂。

void LeafNode::insertNonFull(const Key& k, const Value& v);

KeyNode* LeafNode::split();

KeyNode* LeafNode::insert(const Key& k, const Value& v);

这三个叶子节点函数与中间结点的功能是差不多的，但是因为中间节点与叶子节点的结构有很大的差别，所以写法会有不同。值得注意的一点是，叶子节点的分裂函数返回的keynode，key是右边的node的第一个key，即左闭右开原则，所以叶子节点最多有2d个key，与中间结点不同。

完成了这些函数之后，最后把makefile修改一下然后执行，最后通过google test就完成了。




  




